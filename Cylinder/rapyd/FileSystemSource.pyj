"""For server file-system synchronisation
    Planned to support: storing an internally cached tree
"""

@external
class NamedCallbacks:
    pass

define(["NamedCallbacks"], def(NamedCallbacks):

    class FileSystemSource(NamedCallbacks):
        def __init__(self, connection):
            NamedCallbacks.__init__(self)
            self.connection = connection
            self.CMD_LISTDIR = "list_dir"

            #self.rootNode = EntityNode(None, "~", "d")

            self.connection.subscribe(self.CMD_LISTDIR, self.onDirectoryListing.bind(self, None))

        def getConnection(self):
            return self.connection

        def onDirectoryListing(self, cb, response):
            if response.status != "Completed" or response.result is False:
                console.log("Unable to get directory listing: ", response)
            else:
                path = response.data.path
                list = response.data.list
                console.log("Got directory listing for " + path)
                if cb:
                    cb(path, list)

        def fetchDirectory(self, path, cb=None):
            self.connection.sendCommand(self.CMD_LISTDIR, {path: path}, self.onDirectoryListing.bind(self,cb))

    return FileSystemSource
)

"""

    class EntityNode:
        def __init__(self, parentNode, name, type):
            self.parentNode = parentNode
            self.name = name
            self.children = []
            self.type = type

        def getName(self):
            return self.name

        def getParentNode(self):
            return self.parentNode

        def getChildren(self):
            return self.children

        def getType(self):
            return self.type

        def getChildNode(self, name):
            for node in self.children:
                if node.name == name:
                    return node
            return None

        def generateParts(self):
            parentParts = []
            if not self.isRoot():
                parentParts.push( self.parentNode.generateParts() )
            parentParts.push(self.name)
            return parentParts

        def isRoot(self):
            return self.parentNode is None

        def getRootNode(self):
            if self.isRoot():
                return self
            return self.parentNode.getRootNode()

        def findNode(self, parts, create=false):
            name = parts[0]
            if name == self.name:
                return self
            childNode = self.getChildNode(name)
            if childNode is not None:
                parts.shift()
                return childNode.findNode(parts)
            elif create:
                root = self
                while parts.length > 0:
                    name = parts.shift()
                    root.children.push( EntityNode(root, name,"d") )
                    root = root.children[root.children.length]
                return root
            return None

"""